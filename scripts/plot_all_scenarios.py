#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generate comparison plots for all scenarios using the latest CSV summary.

Outputs are saved under results/plots/tmt_analysis/.
Charts:
- Bar chart: TMT (before vs after) per scenario
- Bar chart: Coordination (before vs after) per scenario
- Bar chart: TMT improvement per scenario (sorted)
- Scatter: Coordination vs TMT (before/after)
"""

import os
import re
import json
from pathlib import Path
from datetime import datetime
from typing import List, Tuple

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


def _find_latest_with_regex(tables_dir: Path, regex: str) -> Path:
    pattern = re.compile(regex)
    candidates: List[Tuple[datetime, Path]] = []
    for p in tables_dir.iterdir():
        if p.is_file() and pattern.match(p.name):
            parts = p.stem.split("_")
            try:
                dt = datetime.strptime(parts[-2] + parts[-1], "%Y%m%d%H%M%S")
            except Exception:
                try:
                    dt = datetime.strptime(p.stem[-15:], "%Y%m%d_%H%M%S")
                except Exception:
                    continue
            candidates.append((dt, p))
    if not candidates:
        return None
    candidates.sort(key=lambda t: t[0])
    return candidates[-1][1]


def find_latest_summary_csv(tables_dir: Path) -> Path:
    """Return path to latest CSV summary. Prefer comprehensive naming; fallback to automation naming."""
    if not tables_dir.exists():
        return None
    # Preferred: comprehensive CSV generated by generate_comprehensive_report.py
    csv_path = _find_latest_with_regex(tables_dir, r"^all_68_scenarios_summary_\d{8}_\d{6}\.csv$")
    if csv_path:
        return csv_path
    # Fallback: automation CSV produced by notebooks/automation
    return _find_latest_with_regex(tables_dir, r"^tmt_analysis_automation_all_scenarios_results_\d{8}_\d{6}\.csv$")


def load_summary(csv_path: Path) -> pd.DataFrame:
    """Load the summary CSV and normalize types."""
    df = pd.read_csv(csv_path)
    # Ensure scenario order is natural (scenario_1..scenario_68)
    def scenario_key(s: str) -> int:
        try:
            return int(str(s).split("_")[-1])
        except Exception:
            return 0
    # Normalize columns in case of fallback CSV
    rename_map = {
        # Fallback automation CSV may already use similar names; adapt if needed
        "scenario": "Scenario",
        "coordination_percentage": "Coordination_Percentage",
        "tmt": "TMT",
        # Spanish headers from automation CSV
        "Escenario": "Scenario",
        "Porcentaje CoordinaciÃ³n": "Coordination_Percentage",
        "Total Pares VÃ¡lidos": "Total_Pairs",
    }
    for k, v in rename_map.items():
        if k in df.columns and v not in df.columns:
            df = df.rename(columns={k: v})
    if "Scenario" not in df.columns:
        raise ValueError("CSV summary must contain 'Scenario' column")
    df = df.sort_values(by="Scenario", key=lambda s: s.map(scenario_key))
    # Fill missing numeric columns
    numeric_cols = [
        "Total_Pairs","TMT","Coordination_Percentage","Mean_DT","Std_DT","Min_DT","Max_DT",
        "TMT_After","Coord_After","TMT_Improvement","Coord_Improvement"
    ]
    for c in numeric_cols:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce")
    return df


def ensure_output_dir() -> Path:
    out_dir = Path("results/plots/tmt_analysis")
    out_dir.mkdir(parents=True, exist_ok=True)
    return out_dir


def save_fig(fig, out_dir: Path, name: str) -> Path:
    path = out_dir / f"{name}.png"
    fig.savefig(path, dpi=160, bbox_inches="tight")
    plt.close(fig)
    return path


def plot_tmt_before_after(df: pd.DataFrame, out_dir: Path) -> Path:
    fig, ax = plt.subplots(figsize=(16, 6))
    x = np.arange(len(df))
    width = 0.38
    ax.bar(x - width/2, df["TMT"], width=width, label="TMT (Before)")
    if "TMT_After" in df.columns and df["TMT_After"].notna().any():
        ax.bar(x + width/2, df["TMT_After"], width=width, label="TMT (After)")
    ax.set_title("TMT por escenario (antes vs despuÃ©s)")
    ax.set_xlabel("Escenario")
    ax.set_ylabel("TMT (s)")
    ax.set_xticks(x)
    ax.set_xticklabels(df["Scenario"], rotation=90)
    ax.grid(True, axis="y", linestyle=":", alpha=0.5)
    ax.legend()
    return save_fig(fig, out_dir, "tmt_before_after_per_scenario")


def plot_coord_before_after(df: pd.DataFrame, out_dir: Path) -> Path:
    fig, ax = plt.subplots(figsize=(16, 6))
    x = np.arange(len(df))
    width = 0.38
    ax.bar(x - width/2, df["Coordination_Percentage"], width=width, label="CoordinaciÃ³n (Antes)")
    if "Coord_After" in df.columns and df["Coord_After"].notna().any():
        ax.bar(x + width/2, df["Coord_After"], width=width, label="CoordinaciÃ³n (DespuÃ©s)")
    ax.set_title("CoordinaciÃ³n por escenario (antes vs despuÃ©s)")
    ax.set_xlabel("Escenario")
    ax.set_ylabel("CoordinaciÃ³n (%)")
    ax.set_xticks(x)
    ax.set_xticklabels(df["Scenario"], rotation=90)
    ax.set_ylim(0, 100)
    ax.grid(True, axis="y", linestyle=":", alpha=0.5)
    ax.legend()
    return save_fig(fig, out_dir, "coord_before_after_per_scenario")


def plot_tmt_improvement_sorted(df: pd.DataFrame, out_dir: Path) -> Path:
    if "TMT_Improvement" not in df.columns:
        return None
    dfi = df.copy().sort_values("TMT_Improvement", ascending=False)
    fig, ax = plt.subplots(figsize=(14, 7))
    sns.barplot(x="Scenario", y="TMT_Improvement", data=dfi, ax=ax, color="#2c7fb8")
    ax.set_title("Mejora de TMT por escenario (ordenado)")
    ax.set_xlabel("Escenario")
    ax.set_ylabel("Î”TMT (s)")
    ax.set_xticklabels(dfi["Scenario"], rotation=90)
    ax.axhline(0, color="k", linewidth=1)
    ax.grid(True, axis="y", linestyle=":", alpha=0.5)
    return save_fig(fig, out_dir, "tmt_improvement_sorted")


def plot_coord_vs_tmt(df: pd.DataFrame, out_dir: Path) -> Path:
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.scatter(df["TMT"], df["Coordination_Percentage"], alpha=0.7, label="Antes")
    if "TMT_After" in df.columns and "Coord_After" in df.columns and df["TMT_After"].notna().any():
        ax.scatter(df["TMT_After"], df["Coord_After"], alpha=0.7, label="DespuÃ©s")
    ax.set_title("CoordinaciÃ³n vs TMT (antes/despuÃ©s)")
    ax.set_xlabel("TMT (s)")
    ax.set_ylabel("CoordinaciÃ³n (%)")
    ax.grid(True, linestyle=":", alpha=0.5)
    ax.legend()
    return save_fig(fig, out_dir, "coord_vs_tmt_before_after")


def main():
    project_root = Path.cwd()
    tables_dir = project_root / "results" / "tables"
    out_dir = ensure_output_dir()

    csv_path = find_latest_summary_csv(tables_dir)
    if not csv_path or not csv_path.exists():
        print("âŒ No se encontrÃ³ el CSV de resumen en results/tables.")
        return 1

    print(f"ğŸ“„ Usando CSV: {csv_path}")
    df = load_summary(csv_path)

    # Generate plots
    generated = []
    generated.append(plot_tmt_before_after(df, out_dir))
    generated.append(plot_coord_before_after(df, out_dir))
    imp = plot_tmt_improvement_sorted(df, out_dir)
    if imp:
        generated.append(imp)
    generated.append(plot_coord_vs_tmt(df, out_dir))

    print("\nğŸ‰ GrÃ¡ficas generadas:")
    for p in generated:
        print(f"  - {p}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())


